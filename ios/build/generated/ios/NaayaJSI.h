/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook::react {


  class JSI_EXPORT NativeAudioEqualizerModuleCxxSpecJSI : public TurboModule {
protected:
  NativeAudioEqualizerModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void setEQEnabled(jsi::Runtime &rt, bool enabled) = 0;
  virtual bool getEQEnabled(jsi::Runtime &rt) = 0;
  virtual void setMasterGain(jsi::Runtime &rt, double gainDb) = 0;
  virtual double getMasterGain(jsi::Runtime &rt) = 0;
  virtual void setBandGain(jsi::Runtime &rt, double bandIndex, double gain) = 0;
  virtual double getBandGain(jsi::Runtime &rt, double bandIndex) = 0;
  virtual void setPreset(jsi::Runtime &rt, jsi::String presetName) = 0;
  virtual jsi::String getCurrentPreset(jsi::Runtime &rt) = 0;
  virtual jsi::Array getAvailablePresets(jsi::Runtime &rt) = 0;
  virtual jsi::Array getSpectrumData(jsi::Runtime &rt) = 0;
  virtual void startSpectrumAnalysis(jsi::Runtime &rt) = 0;
  virtual void stopSpectrumAnalysis(jsi::Runtime &rt) = 0;
  virtual void beginBatch(jsi::Runtime &rt) = 0;
  virtual void endBatch(jsi::Runtime &rt) = 0;
  virtual void nrSetEnabled(jsi::Runtime &rt, bool enabled) = 0;
  virtual bool nrGetEnabled(jsi::Runtime &rt) = 0;
  virtual void nrSetConfig(jsi::Runtime &rt, bool highPassEnabled, double highPassHz, double thresholdDb, double ratio, double floorDb, double attackMs, double releaseMs) = 0;
  virtual jsi::Object nrGetConfig(jsi::Runtime &rt) = 0;
  virtual void safetySetConfig(jsi::Runtime &rt, bool enabled, bool dcRemovalEnabled, double dcThreshold, bool limiterEnabled, double limiterThresholdDb, bool softKneeLimiter, double kneeWidthDb, bool feedbackDetectEnabled, double feedbackCorrThreshold) = 0;
  virtual jsi::Object safetyGetReport(jsi::Runtime &rt) = 0;
  virtual void fxSetEnabled(jsi::Runtime &rt, bool enabled) = 0;
  virtual bool fxGetEnabled(jsi::Runtime &rt) = 0;
  virtual void fxSetCompressor(jsi::Runtime &rt, double thresholdDb, double ratio, double attackMs, double releaseMs, double makeupDb) = 0;
  virtual void fxSetDelay(jsi::Runtime &rt, double delayMs, double feedback, double mix) = 0;

};

template <typename T>
class JSI_EXPORT NativeAudioEqualizerModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = "NativeAudioEqualizerModule";

protected:
  NativeAudioEqualizerModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeAudioEqualizerModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeAudioEqualizerModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeAudioEqualizerModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    void setEQEnabled(jsi::Runtime &rt, bool enabled) override {
      static_assert(
          bridging::getParameterCount(&T::setEQEnabled) == 2,
          "Expected setEQEnabled(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setEQEnabled, jsInvoker_, instance_, std::move(enabled));
    }
    bool getEQEnabled(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getEQEnabled) == 1,
          "Expected getEQEnabled(...) to have 1 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::getEQEnabled, jsInvoker_, instance_);
    }
    void setMasterGain(jsi::Runtime &rt, double gainDb) override {
      static_assert(
          bridging::getParameterCount(&T::setMasterGain) == 2,
          "Expected setMasterGain(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setMasterGain, jsInvoker_, instance_, std::move(gainDb));
    }
    double getMasterGain(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getMasterGain) == 1,
          "Expected getMasterGain(...) to have 1 parameters");

      return bridging::callFromJs<double>(
          rt, &T::getMasterGain, jsInvoker_, instance_);
    }
    void setBandGain(jsi::Runtime &rt, double bandIndex, double gain) override {
      static_assert(
          bridging::getParameterCount(&T::setBandGain) == 3,
          "Expected setBandGain(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setBandGain, jsInvoker_, instance_, std::move(bandIndex), std::move(gain));
    }
    double getBandGain(jsi::Runtime &rt, double bandIndex) override {
      static_assert(
          bridging::getParameterCount(&T::getBandGain) == 2,
          "Expected getBandGain(...) to have 2 parameters");

      return bridging::callFromJs<double>(
          rt, &T::getBandGain, jsInvoker_, instance_, std::move(bandIndex));
    }
    void setPreset(jsi::Runtime &rt, jsi::String presetName) override {
      static_assert(
          bridging::getParameterCount(&T::setPreset) == 2,
          "Expected setPreset(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setPreset, jsInvoker_, instance_, std::move(presetName));
    }
    jsi::String getCurrentPreset(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getCurrentPreset) == 1,
          "Expected getCurrentPreset(...) to have 1 parameters");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getCurrentPreset, jsInvoker_, instance_);
    }
    jsi::Array getAvailablePresets(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getAvailablePresets) == 1,
          "Expected getAvailablePresets(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getAvailablePresets, jsInvoker_, instance_);
    }
    jsi::Array getSpectrumData(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getSpectrumData) == 1,
          "Expected getSpectrumData(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getSpectrumData, jsInvoker_, instance_);
    }
    void startSpectrumAnalysis(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::startSpectrumAnalysis) == 1,
          "Expected startSpectrumAnalysis(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::startSpectrumAnalysis, jsInvoker_, instance_);
    }
    void stopSpectrumAnalysis(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::stopSpectrumAnalysis) == 1,
          "Expected stopSpectrumAnalysis(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::stopSpectrumAnalysis, jsInvoker_, instance_);
    }
    void beginBatch(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::beginBatch) == 1,
          "Expected beginBatch(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::beginBatch, jsInvoker_, instance_);
    }
    void endBatch(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::endBatch) == 1,
          "Expected endBatch(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::endBatch, jsInvoker_, instance_);
    }
    void nrSetEnabled(jsi::Runtime &rt, bool enabled) override {
      static_assert(
          bridging::getParameterCount(&T::nrSetEnabled) == 2,
          "Expected nrSetEnabled(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::nrSetEnabled, jsInvoker_, instance_, std::move(enabled));
    }
    bool nrGetEnabled(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::nrGetEnabled) == 1,
          "Expected nrGetEnabled(...) to have 1 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::nrGetEnabled, jsInvoker_, instance_);
    }
    void nrSetConfig(jsi::Runtime &rt, bool highPassEnabled, double highPassHz, double thresholdDb, double ratio, double floorDb, double attackMs, double releaseMs) override {
      static_assert(
          bridging::getParameterCount(&T::nrSetConfig) == 8,
          "Expected nrSetConfig(...) to have 8 parameters");

      return bridging::callFromJs<void>(
          rt, &T::nrSetConfig, jsInvoker_, instance_, std::move(highPassEnabled), std::move(highPassHz), std::move(thresholdDb), std::move(ratio), std::move(floorDb), std::move(attackMs), std::move(releaseMs));
    }
    jsi::Object nrGetConfig(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::nrGetConfig) == 1,
          "Expected nrGetConfig(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::nrGetConfig, jsInvoker_, instance_);
    }
    void safetySetConfig(jsi::Runtime &rt, bool enabled, bool dcRemovalEnabled, double dcThreshold, bool limiterEnabled, double limiterThresholdDb, bool softKneeLimiter, double kneeWidthDb, bool feedbackDetectEnabled, double feedbackCorrThreshold) override {
      static_assert(
          bridging::getParameterCount(&T::safetySetConfig) == 10,
          "Expected safetySetConfig(...) to have 10 parameters");

      return bridging::callFromJs<void>(
          rt, &T::safetySetConfig, jsInvoker_, instance_, std::move(enabled), std::move(dcRemovalEnabled), std::move(dcThreshold), std::move(limiterEnabled), std::move(limiterThresholdDb), std::move(softKneeLimiter), std::move(kneeWidthDb), std::move(feedbackDetectEnabled), std::move(feedbackCorrThreshold));
    }
    jsi::Object safetyGetReport(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::safetyGetReport) == 1,
          "Expected safetyGetReport(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::safetyGetReport, jsInvoker_, instance_);
    }
    void fxSetEnabled(jsi::Runtime &rt, bool enabled) override {
      static_assert(
          bridging::getParameterCount(&T::fxSetEnabled) == 2,
          "Expected fxSetEnabled(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::fxSetEnabled, jsInvoker_, instance_, std::move(enabled));
    }
    bool fxGetEnabled(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::fxGetEnabled) == 1,
          "Expected fxGetEnabled(...) to have 1 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::fxGetEnabled, jsInvoker_, instance_);
    }
    void fxSetCompressor(jsi::Runtime &rt, double thresholdDb, double ratio, double attackMs, double releaseMs, double makeupDb) override {
      static_assert(
          bridging::getParameterCount(&T::fxSetCompressor) == 6,
          "Expected fxSetCompressor(...) to have 6 parameters");

      return bridging::callFromJs<void>(
          rt, &T::fxSetCompressor, jsInvoker_, instance_, std::move(thresholdDb), std::move(ratio), std::move(attackMs), std::move(releaseMs), std::move(makeupDb));
    }
    void fxSetDelay(jsi::Runtime &rt, double delayMs, double feedback, double mix) override {
      static_assert(
          bridging::getParameterCount(&T::fxSetDelay) == 4,
          "Expected fxSetDelay(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::fxSetDelay, jsInvoker_, instance_, std::move(delayMs), std::move(feedback), std::move(mix));
    }

  private:
    friend class NativeAudioEqualizerModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - NativeCameraFiltersModuleAdvancedFilterParams

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11>
struct NativeCameraFiltersModuleAdvancedFilterParams {
  P0 brightness;
  P1 contrast;
  P2 saturation;
  P3 hue;
  P4 gamma;
  P5 warmth;
  P6 tint;
  P7 exposure;
  P8 shadows;
  P9 highlights;
  P10 vignette;
  P11 grain;
  bool operator==(const NativeCameraFiltersModuleAdvancedFilterParams &other) const {
    return brightness == other.brightness && contrast == other.contrast && saturation == other.saturation && hue == other.hue && gamma == other.gamma && warmth == other.warmth && tint == other.tint && exposure == other.exposure && shadows == other.shadows && highlights == other.highlights && vignette == other.vignette && grain == other.grain;
  }
};

template <typename T>
struct NativeCameraFiltersModuleAdvancedFilterParamsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.brightness)>(rt, value.getProperty(rt, "brightness"), jsInvoker),
      bridging::fromJs<decltype(types.contrast)>(rt, value.getProperty(rt, "contrast"), jsInvoker),
      bridging::fromJs<decltype(types.saturation)>(rt, value.getProperty(rt, "saturation"), jsInvoker),
      bridging::fromJs<decltype(types.hue)>(rt, value.getProperty(rt, "hue"), jsInvoker),
      bridging::fromJs<decltype(types.gamma)>(rt, value.getProperty(rt, "gamma"), jsInvoker),
      bridging::fromJs<decltype(types.warmth)>(rt, value.getProperty(rt, "warmth"), jsInvoker),
      bridging::fromJs<decltype(types.tint)>(rt, value.getProperty(rt, "tint"), jsInvoker),
      bridging::fromJs<decltype(types.exposure)>(rt, value.getProperty(rt, "exposure"), jsInvoker),
      bridging::fromJs<decltype(types.shadows)>(rt, value.getProperty(rt, "shadows"), jsInvoker),
      bridging::fromJs<decltype(types.highlights)>(rt, value.getProperty(rt, "highlights"), jsInvoker),
      bridging::fromJs<decltype(types.vignette)>(rt, value.getProperty(rt, "vignette"), jsInvoker),
      bridging::fromJs<decltype(types.grain)>(rt, value.getProperty(rt, "grain"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double brightnessToJs(jsi::Runtime &rt, decltype(types.brightness) value) {
    return bridging::toJs(rt, value);
  }

  static double contrastToJs(jsi::Runtime &rt, decltype(types.contrast) value) {
    return bridging::toJs(rt, value);
  }

  static double saturationToJs(jsi::Runtime &rt, decltype(types.saturation) value) {
    return bridging::toJs(rt, value);
  }

  static double hueToJs(jsi::Runtime &rt, decltype(types.hue) value) {
    return bridging::toJs(rt, value);
  }

  static double gammaToJs(jsi::Runtime &rt, decltype(types.gamma) value) {
    return bridging::toJs(rt, value);
  }

  static double warmthToJs(jsi::Runtime &rt, decltype(types.warmth) value) {
    return bridging::toJs(rt, value);
  }

  static double tintToJs(jsi::Runtime &rt, decltype(types.tint) value) {
    return bridging::toJs(rt, value);
  }

  static double exposureToJs(jsi::Runtime &rt, decltype(types.exposure) value) {
    return bridging::toJs(rt, value);
  }

  static double shadowsToJs(jsi::Runtime &rt, decltype(types.shadows) value) {
    return bridging::toJs(rt, value);
  }

  static double highlightsToJs(jsi::Runtime &rt, decltype(types.highlights) value) {
    return bridging::toJs(rt, value);
  }

  static double vignetteToJs(jsi::Runtime &rt, decltype(types.vignette) value) {
    return bridging::toJs(rt, value);
  }

  static double grainToJs(jsi::Runtime &rt, decltype(types.grain) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "brightness", bridging::toJs(rt, value.brightness, jsInvoker));
    result.setProperty(rt, "contrast", bridging::toJs(rt, value.contrast, jsInvoker));
    result.setProperty(rt, "saturation", bridging::toJs(rt, value.saturation, jsInvoker));
    result.setProperty(rt, "hue", bridging::toJs(rt, value.hue, jsInvoker));
    result.setProperty(rt, "gamma", bridging::toJs(rt, value.gamma, jsInvoker));
    result.setProperty(rt, "warmth", bridging::toJs(rt, value.warmth, jsInvoker));
    result.setProperty(rt, "tint", bridging::toJs(rt, value.tint, jsInvoker));
    result.setProperty(rt, "exposure", bridging::toJs(rt, value.exposure, jsInvoker));
    result.setProperty(rt, "shadows", bridging::toJs(rt, value.shadows, jsInvoker));
    result.setProperty(rt, "highlights", bridging::toJs(rt, value.highlights, jsInvoker));
    result.setProperty(rt, "vignette", bridging::toJs(rt, value.vignette, jsInvoker));
    result.setProperty(rt, "grain", bridging::toJs(rt, value.grain, jsInvoker));
    return result;
  }
};



#pragma mark - NativeCameraFiltersModuleFilterState

template <typename P0, typename P1>
struct NativeCameraFiltersModuleFilterState {
  P0 name;
  P1 intensity;
  bool operator==(const NativeCameraFiltersModuleFilterState &other) const {
    return name == other.name && intensity == other.intensity;
  }
};

template <typename T>
struct NativeCameraFiltersModuleFilterStateBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.name)>(rt, value.getProperty(rt, "name"), jsInvoker),
      bridging::fromJs<decltype(types.intensity)>(rt, value.getProperty(rt, "intensity"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String nameToJs(jsi::Runtime &rt, decltype(types.name) value) {
    return bridging::toJs(rt, value);
  }

  static double intensityToJs(jsi::Runtime &rt, decltype(types.intensity) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "name", bridging::toJs(rt, value.name, jsInvoker));
    result.setProperty(rt, "intensity", bridging::toJs(rt, value.intensity, jsInvoker));
    return result;
  }
};

class JSI_EXPORT NativeCameraFiltersModuleCxxSpecJSI : public TurboModule {
protected:
  NativeCameraFiltersModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Array getAvailableFilters(jsi::Runtime &rt) = 0;
  virtual bool setFilter(jsi::Runtime &rt, jsi::String name, double intensity) = 0;
  virtual std::optional<jsi::Object> getFilter(jsi::Runtime &rt) = 0;
  virtual bool clearFilter(jsi::Runtime &rt) = 0;
  virtual bool setFilterWithParams(jsi::Runtime &rt, jsi::String name, double intensity, jsi::Object params) = 0;

};

template <typename T>
class JSI_EXPORT NativeCameraFiltersModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = "NativeCameraFiltersModule";

protected:
  NativeCameraFiltersModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeCameraFiltersModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeCameraFiltersModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeCameraFiltersModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Array getAvailableFilters(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getAvailableFilters) == 1,
          "Expected getAvailableFilters(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getAvailableFilters, jsInvoker_, instance_);
    }
    bool setFilter(jsi::Runtime &rt, jsi::String name, double intensity) override {
      static_assert(
          bridging::getParameterCount(&T::setFilter) == 3,
          "Expected setFilter(...) to have 3 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::setFilter, jsInvoker_, instance_, std::move(name), std::move(intensity));
    }
    std::optional<jsi::Object> getFilter(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getFilter) == 1,
          "Expected getFilter(...) to have 1 parameters");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getFilter, jsInvoker_, instance_);
    }
    bool clearFilter(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::clearFilter) == 1,
          "Expected clearFilter(...) to have 1 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::clearFilter, jsInvoker_, instance_);
    }
    bool setFilterWithParams(jsi::Runtime &rt, jsi::String name, double intensity, jsi::Object params) override {
      static_assert(
          bridging::getParameterCount(&T::setFilterWithParams) == 4,
          "Expected setFilterWithParams(...) to have 4 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::setFilterWithParams, jsInvoker_, instance_, std::move(name), std::move(intensity), std::move(params));
    }

  private:
    friend class NativeCameraFiltersModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - NativeCameraModuleCameraDevice

template <typename P0, typename P1, typename P2, typename P3>
struct NativeCameraModuleCameraDevice {
  P0 id;
  P1 name;
  P2 position;
  P3 hasFlash;
  bool operator==(const NativeCameraModuleCameraDevice &other) const {
    return id == other.id && name == other.name && position == other.position && hasFlash == other.hasFlash;
  }
};

template <typename T>
struct NativeCameraModuleCameraDeviceBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.id)>(rt, value.getProperty(rt, "id"), jsInvoker),
      bridging::fromJs<decltype(types.name)>(rt, value.getProperty(rt, "name"), jsInvoker),
      bridging::fromJs<decltype(types.position)>(rt, value.getProperty(rt, "position"), jsInvoker),
      bridging::fromJs<decltype(types.hasFlash)>(rt, value.getProperty(rt, "hasFlash"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String idToJs(jsi::Runtime &rt, decltype(types.id) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String nameToJs(jsi::Runtime &rt, decltype(types.name) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String positionToJs(jsi::Runtime &rt, decltype(types.position) value) {
    return bridging::toJs(rt, value);
  }

  static bool hasFlashToJs(jsi::Runtime &rt, decltype(types.hasFlash) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "id", bridging::toJs(rt, value.id, jsInvoker));
    result.setProperty(rt, "name", bridging::toJs(rt, value.name, jsInvoker));
    result.setProperty(rt, "position", bridging::toJs(rt, value.position, jsInvoker));
    result.setProperty(rt, "hasFlash", bridging::toJs(rt, value.hasFlash, jsInvoker));
    return result;
  }
};



#pragma mark - NativeCameraModulePermissionResult

template <typename P0, typename P1, typename P2>
struct NativeCameraModulePermissionResult {
  P0 camera;
  P1 microphone;
  P2 storage;
  bool operator==(const NativeCameraModulePermissionResult &other) const {
    return camera == other.camera && microphone == other.microphone && storage == other.storage;
  }
};

template <typename T>
struct NativeCameraModulePermissionResultBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.camera)>(rt, value.getProperty(rt, "camera"), jsInvoker),
      bridging::fromJs<decltype(types.microphone)>(rt, value.getProperty(rt, "microphone"), jsInvoker),
      bridging::fromJs<decltype(types.storage)>(rt, value.getProperty(rt, "storage"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String cameraToJs(jsi::Runtime &rt, decltype(types.camera) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String microphoneToJs(jsi::Runtime &rt, decltype(types.microphone) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String storageToJs(jsi::Runtime &rt, decltype(types.storage) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "camera", bridging::toJs(rt, value.camera, jsInvoker));
    result.setProperty(rt, "microphone", bridging::toJs(rt, value.microphone, jsInvoker));
    result.setProperty(rt, "storage", bridging::toJs(rt, value.storage, jsInvoker));
    return result;
  }
};



#pragma mark - NativeCameraModulePhotoCaptureOptions

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5>
struct NativeCameraModulePhotoCaptureOptions {
  P0 quality;
  P1 base64;
  P2 exif;
  P3 skipMetadata;
  P4 format;
  P5 deviceId;
  bool operator==(const NativeCameraModulePhotoCaptureOptions &other) const {
    return quality == other.quality && base64 == other.base64 && exif == other.exif && skipMetadata == other.skipMetadata && format == other.format && deviceId == other.deviceId;
  }
};

template <typename T>
struct NativeCameraModulePhotoCaptureOptionsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.quality)>(rt, value.getProperty(rt, "quality"), jsInvoker),
      bridging::fromJs<decltype(types.base64)>(rt, value.getProperty(rt, "base64"), jsInvoker),
      bridging::fromJs<decltype(types.exif)>(rt, value.getProperty(rt, "exif"), jsInvoker),
      bridging::fromJs<decltype(types.skipMetadata)>(rt, value.getProperty(rt, "skipMetadata"), jsInvoker),
      bridging::fromJs<decltype(types.format)>(rt, value.getProperty(rt, "format"), jsInvoker),
      bridging::fromJs<decltype(types.deviceId)>(rt, value.getProperty(rt, "deviceId"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double qualityToJs(jsi::Runtime &rt, decltype(types.quality) value) {
    return bridging::toJs(rt, value);
  }

  static bool base64ToJs(jsi::Runtime &rt, decltype(types.base64) value) {
    return bridging::toJs(rt, value);
  }

  static bool exifToJs(jsi::Runtime &rt, decltype(types.exif) value) {
    return bridging::toJs(rt, value);
  }

  static bool skipMetadataToJs(jsi::Runtime &rt, decltype(types.skipMetadata) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String formatToJs(jsi::Runtime &rt, decltype(types.format) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String deviceIdToJs(jsi::Runtime &rt, decltype(types.deviceId) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.quality) {
      result.setProperty(rt, "quality", bridging::toJs(rt, value.quality.value(), jsInvoker));
    }
    if (value.base64) {
      result.setProperty(rt, "base64", bridging::toJs(rt, value.base64.value(), jsInvoker));
    }
    if (value.exif) {
      result.setProperty(rt, "exif", bridging::toJs(rt, value.exif.value(), jsInvoker));
    }
    if (value.skipMetadata) {
      result.setProperty(rt, "skipMetadata", bridging::toJs(rt, value.skipMetadata.value(), jsInvoker));
    }
    if (value.format) {
      result.setProperty(rt, "format", bridging::toJs(rt, value.format.value(), jsInvoker));
    }
    if (value.deviceId) {
      result.setProperty(rt, "deviceId", bridging::toJs(rt, value.deviceId.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeCameraModulePhotoResult

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct NativeCameraModulePhotoResult {
  P0 uri;
  P1 width;
  P2 height;
  P3 base64;
  P4 exif;
  bool operator==(const NativeCameraModulePhotoResult &other) const {
    return uri == other.uri && width == other.width && height == other.height && base64 == other.base64 && exif == other.exif;
  }
};

template <typename T>
struct NativeCameraModulePhotoResultBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.uri)>(rt, value.getProperty(rt, "uri"), jsInvoker),
      bridging::fromJs<decltype(types.width)>(rt, value.getProperty(rt, "width"), jsInvoker),
      bridging::fromJs<decltype(types.height)>(rt, value.getProperty(rt, "height"), jsInvoker),
      bridging::fromJs<decltype(types.base64)>(rt, value.getProperty(rt, "base64"), jsInvoker),
      bridging::fromJs<decltype(types.exif)>(rt, value.getProperty(rt, "exif"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String uriToJs(jsi::Runtime &rt, decltype(types.uri) value) {
    return bridging::toJs(rt, value);
  }

  static double widthToJs(jsi::Runtime &rt, decltype(types.width) value) {
    return bridging::toJs(rt, value);
  }

  static double heightToJs(jsi::Runtime &rt, decltype(types.height) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String base64ToJs(jsi::Runtime &rt, decltype(types.base64) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object exifToJs(jsi::Runtime &rt, decltype(types.exif) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "uri", bridging::toJs(rt, value.uri, jsInvoker));
    result.setProperty(rt, "width", bridging::toJs(rt, value.width, jsInvoker));
    result.setProperty(rt, "height", bridging::toJs(rt, value.height, jsInvoker));
    if (value.base64) {
      result.setProperty(rt, "base64", bridging::toJs(rt, value.base64.value(), jsInvoker));
    }
    if (value.exif) {
      result.setProperty(rt, "exif", bridging::toJs(rt, value.exif.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeCameraModuleVideoCaptureOptions

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12, typename P13, typename P14, typename P15, typename P16, typename P17, typename P18, typename P19>
struct NativeCameraModuleVideoCaptureOptions {
  P0 quality;
  P1 maxDuration;
  P2 maxFileSize;
  P3 videoBitrate;
  P4 audioBitrate;
  P5 recordAudio;
  P6 codec;
  P7 container;
  P8 audioCodec;
  P9 width;
  P10 height;
  P11 fps;
  P12 deviceId;
  P13 orientation;
  P14 stabilization;
  P15 lockAE;
  P16 lockAWB;
  P17 lockAF;
  P18 saveDirectory;
  P19 fileNamePrefix;
  bool operator==(const NativeCameraModuleVideoCaptureOptions &other) const {
    return quality == other.quality && maxDuration == other.maxDuration && maxFileSize == other.maxFileSize && videoBitrate == other.videoBitrate && audioBitrate == other.audioBitrate && recordAudio == other.recordAudio && codec == other.codec && container == other.container && audioCodec == other.audioCodec && width == other.width && height == other.height && fps == other.fps && deviceId == other.deviceId && orientation == other.orientation && stabilization == other.stabilization && lockAE == other.lockAE && lockAWB == other.lockAWB && lockAF == other.lockAF && saveDirectory == other.saveDirectory && fileNamePrefix == other.fileNamePrefix;
  }
};

template <typename T>
struct NativeCameraModuleVideoCaptureOptionsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.quality)>(rt, value.getProperty(rt, "quality"), jsInvoker),
      bridging::fromJs<decltype(types.maxDuration)>(rt, value.getProperty(rt, "maxDuration"), jsInvoker),
      bridging::fromJs<decltype(types.maxFileSize)>(rt, value.getProperty(rt, "maxFileSize"), jsInvoker),
      bridging::fromJs<decltype(types.videoBitrate)>(rt, value.getProperty(rt, "videoBitrate"), jsInvoker),
      bridging::fromJs<decltype(types.audioBitrate)>(rt, value.getProperty(rt, "audioBitrate"), jsInvoker),
      bridging::fromJs<decltype(types.recordAudio)>(rt, value.getProperty(rt, "recordAudio"), jsInvoker),
      bridging::fromJs<decltype(types.codec)>(rt, value.getProperty(rt, "codec"), jsInvoker),
      bridging::fromJs<decltype(types.container)>(rt, value.getProperty(rt, "container"), jsInvoker),
      bridging::fromJs<decltype(types.audioCodec)>(rt, value.getProperty(rt, "audioCodec"), jsInvoker),
      bridging::fromJs<decltype(types.width)>(rt, value.getProperty(rt, "width"), jsInvoker),
      bridging::fromJs<decltype(types.height)>(rt, value.getProperty(rt, "height"), jsInvoker),
      bridging::fromJs<decltype(types.fps)>(rt, value.getProperty(rt, "fps"), jsInvoker),
      bridging::fromJs<decltype(types.deviceId)>(rt, value.getProperty(rt, "deviceId"), jsInvoker),
      bridging::fromJs<decltype(types.orientation)>(rt, value.getProperty(rt, "orientation"), jsInvoker),
      bridging::fromJs<decltype(types.stabilization)>(rt, value.getProperty(rt, "stabilization"), jsInvoker),
      bridging::fromJs<decltype(types.lockAE)>(rt, value.getProperty(rt, "lockAE"), jsInvoker),
      bridging::fromJs<decltype(types.lockAWB)>(rt, value.getProperty(rt, "lockAWB"), jsInvoker),
      bridging::fromJs<decltype(types.lockAF)>(rt, value.getProperty(rt, "lockAF"), jsInvoker),
      bridging::fromJs<decltype(types.saveDirectory)>(rt, value.getProperty(rt, "saveDirectory"), jsInvoker),
      bridging::fromJs<decltype(types.fileNamePrefix)>(rt, value.getProperty(rt, "fileNamePrefix"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String qualityToJs(jsi::Runtime &rt, decltype(types.quality) value) {
    return bridging::toJs(rt, value);
  }

  static double maxDurationToJs(jsi::Runtime &rt, decltype(types.maxDuration) value) {
    return bridging::toJs(rt, value);
  }

  static double maxFileSizeToJs(jsi::Runtime &rt, decltype(types.maxFileSize) value) {
    return bridging::toJs(rt, value);
  }

  static double videoBitrateToJs(jsi::Runtime &rt, decltype(types.videoBitrate) value) {
    return bridging::toJs(rt, value);
  }

  static double audioBitrateToJs(jsi::Runtime &rt, decltype(types.audioBitrate) value) {
    return bridging::toJs(rt, value);
  }

  static bool recordAudioToJs(jsi::Runtime &rt, decltype(types.recordAudio) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String codecToJs(jsi::Runtime &rt, decltype(types.codec) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String containerToJs(jsi::Runtime &rt, decltype(types.container) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String audioCodecToJs(jsi::Runtime &rt, decltype(types.audioCodec) value) {
    return bridging::toJs(rt, value);
  }

  static double widthToJs(jsi::Runtime &rt, decltype(types.width) value) {
    return bridging::toJs(rt, value);
  }

  static double heightToJs(jsi::Runtime &rt, decltype(types.height) value) {
    return bridging::toJs(rt, value);
  }

  static double fpsToJs(jsi::Runtime &rt, decltype(types.fps) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String deviceIdToJs(jsi::Runtime &rt, decltype(types.deviceId) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String orientationToJs(jsi::Runtime &rt, decltype(types.orientation) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String stabilizationToJs(jsi::Runtime &rt, decltype(types.stabilization) value) {
    return bridging::toJs(rt, value);
  }

  static bool lockAEToJs(jsi::Runtime &rt, decltype(types.lockAE) value) {
    return bridging::toJs(rt, value);
  }

  static bool lockAWBToJs(jsi::Runtime &rt, decltype(types.lockAWB) value) {
    return bridging::toJs(rt, value);
  }

  static bool lockAFToJs(jsi::Runtime &rt, decltype(types.lockAF) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String saveDirectoryToJs(jsi::Runtime &rt, decltype(types.saveDirectory) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String fileNamePrefixToJs(jsi::Runtime &rt, decltype(types.fileNamePrefix) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.quality) {
      result.setProperty(rt, "quality", bridging::toJs(rt, value.quality.value(), jsInvoker));
    }
    if (value.maxDuration) {
      result.setProperty(rt, "maxDuration", bridging::toJs(rt, value.maxDuration.value(), jsInvoker));
    }
    if (value.maxFileSize) {
      result.setProperty(rt, "maxFileSize", bridging::toJs(rt, value.maxFileSize.value(), jsInvoker));
    }
    if (value.videoBitrate) {
      result.setProperty(rt, "videoBitrate", bridging::toJs(rt, value.videoBitrate.value(), jsInvoker));
    }
    if (value.audioBitrate) {
      result.setProperty(rt, "audioBitrate", bridging::toJs(rt, value.audioBitrate.value(), jsInvoker));
    }
    if (value.recordAudio) {
      result.setProperty(rt, "recordAudio", bridging::toJs(rt, value.recordAudio.value(), jsInvoker));
    }
    if (value.codec) {
      result.setProperty(rt, "codec", bridging::toJs(rt, value.codec.value(), jsInvoker));
    }
    if (value.container) {
      result.setProperty(rt, "container", bridging::toJs(rt, value.container.value(), jsInvoker));
    }
    if (value.audioCodec) {
      result.setProperty(rt, "audioCodec", bridging::toJs(rt, value.audioCodec.value(), jsInvoker));
    }
    if (value.width) {
      result.setProperty(rt, "width", bridging::toJs(rt, value.width.value(), jsInvoker));
    }
    if (value.height) {
      result.setProperty(rt, "height", bridging::toJs(rt, value.height.value(), jsInvoker));
    }
    if (value.fps) {
      result.setProperty(rt, "fps", bridging::toJs(rt, value.fps.value(), jsInvoker));
    }
    if (value.deviceId) {
      result.setProperty(rt, "deviceId", bridging::toJs(rt, value.deviceId.value(), jsInvoker));
    }
    if (value.orientation) {
      result.setProperty(rt, "orientation", bridging::toJs(rt, value.orientation.value(), jsInvoker));
    }
    if (value.stabilization) {
      result.setProperty(rt, "stabilization", bridging::toJs(rt, value.stabilization.value(), jsInvoker));
    }
    if (value.lockAE) {
      result.setProperty(rt, "lockAE", bridging::toJs(rt, value.lockAE.value(), jsInvoker));
    }
    if (value.lockAWB) {
      result.setProperty(rt, "lockAWB", bridging::toJs(rt, value.lockAWB.value(), jsInvoker));
    }
    if (value.lockAF) {
      result.setProperty(rt, "lockAF", bridging::toJs(rt, value.lockAF.value(), jsInvoker));
    }
    if (value.saveDirectory) {
      result.setProperty(rt, "saveDirectory", bridging::toJs(rt, value.saveDirectory.value(), jsInvoker));
    }
    if (value.fileNamePrefix) {
      result.setProperty(rt, "fileNamePrefix", bridging::toJs(rt, value.fileNamePrefix.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeCameraModuleVideoResult

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct NativeCameraModuleVideoResult {
  P0 uri;
  P1 duration;
  P2 size;
  P3 width;
  P4 height;
  bool operator==(const NativeCameraModuleVideoResult &other) const {
    return uri == other.uri && duration == other.duration && size == other.size && width == other.width && height == other.height;
  }
};

template <typename T>
struct NativeCameraModuleVideoResultBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.uri)>(rt, value.getProperty(rt, "uri"), jsInvoker),
      bridging::fromJs<decltype(types.duration)>(rt, value.getProperty(rt, "duration"), jsInvoker),
      bridging::fromJs<decltype(types.size)>(rt, value.getProperty(rt, "size"), jsInvoker),
      bridging::fromJs<decltype(types.width)>(rt, value.getProperty(rt, "width"), jsInvoker),
      bridging::fromJs<decltype(types.height)>(rt, value.getProperty(rt, "height"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String uriToJs(jsi::Runtime &rt, decltype(types.uri) value) {
    return bridging::toJs(rt, value);
  }

  static double durationToJs(jsi::Runtime &rt, decltype(types.duration) value) {
    return bridging::toJs(rt, value);
  }

  static double sizeToJs(jsi::Runtime &rt, decltype(types.size) value) {
    return bridging::toJs(rt, value);
  }

  static double widthToJs(jsi::Runtime &rt, decltype(types.width) value) {
    return bridging::toJs(rt, value);
  }

  static double heightToJs(jsi::Runtime &rt, decltype(types.height) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "uri", bridging::toJs(rt, value.uri, jsInvoker));
    result.setProperty(rt, "duration", bridging::toJs(rt, value.duration, jsInvoker));
    result.setProperty(rt, "size", bridging::toJs(rt, value.size, jsInvoker));
    result.setProperty(rt, "width", bridging::toJs(rt, value.width, jsInvoker));
    result.setProperty(rt, "height", bridging::toJs(rt, value.height, jsInvoker));
    return result;
  }
};

class JSI_EXPORT NativeCameraModuleCxxSpecJSI : public TurboModule {
protected:
  NativeCameraModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object checkPermissions(jsi::Runtime &rt) = 0;
  virtual jsi::Object requestPermissions(jsi::Runtime &rt) = 0;
  virtual jsi::Array getAvailableDevices(jsi::Runtime &rt) = 0;
  virtual std::optional<jsi::Object> getCurrentDevice(jsi::Runtime &rt) = 0;
  virtual bool selectDevice(jsi::Runtime &rt, jsi::String deviceId) = 0;
  virtual bool switchDevice(jsi::Runtime &rt, jsi::String position) = 0;
  virtual bool startCamera(jsi::Runtime &rt, jsi::String deviceId) = 0;
  virtual bool stopCamera(jsi::Runtime &rt) = 0;
  virtual bool isActive(jsi::Runtime &rt) = 0;
  virtual jsi::Object capturePhoto(jsi::Runtime &rt, jsi::Object options) = 0;
  virtual bool startRecording(jsi::Runtime &rt, jsi::Object options) = 0;
  virtual jsi::Object stopRecording(jsi::Runtime &rt) = 0;
  virtual bool isRecording(jsi::Runtime &rt) = 0;
  virtual jsi::Object getRecordingProgress(jsi::Runtime &rt) = 0;
  virtual bool hasFlash(jsi::Runtime &rt) = 0;
  virtual bool setFlashMode(jsi::Runtime &rt, jsi::String mode) = 0;
  virtual bool setTorchMode(jsi::Runtime &rt, bool enabled) = 0;
  virtual double getMinZoom(jsi::Runtime &rt) = 0;
  virtual double getMaxZoom(jsi::Runtime &rt) = 0;
  virtual bool setZoom(jsi::Runtime &rt, double level) = 0;
  virtual jsi::String getWhiteBalanceMode(jsi::Runtime &rt) = 0;
  virtual bool setWhiteBalanceMode(jsi::Runtime &rt, jsi::String mode) = 0;
  virtual double getWhiteBalanceTemperature(jsi::Runtime &rt) = 0;
  virtual bool setWhiteBalanceTemperature(jsi::Runtime &rt, double kelvin) = 0;
  virtual double getWhiteBalanceTint(jsi::Runtime &rt) = 0;
  virtual bool setWhiteBalanceTint(jsi::Runtime &rt, double tint) = 0;
  virtual jsi::Object getWhiteBalanceGains(jsi::Runtime &rt) = 0;
  virtual bool setWhiteBalanceGains(jsi::Runtime &rt, double red, double green, double blue) = 0;
  virtual jsi::Array getSupportedWhiteBalanceModes(jsi::Runtime &rt) = 0;
  virtual jsi::Object getWhiteBalanceTemperatureRange(jsi::Runtime &rt) = 0;
  virtual jsi::Object getPreviewSize(jsi::Runtime &rt) = 0;
  virtual jsi::Array getSupportedFormats(jsi::Runtime &rt, jsi::String deviceId) = 0;

};

template <typename T>
class JSI_EXPORT NativeCameraModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = "NativeCameraModule";

protected:
  NativeCameraModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeCameraModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeCameraModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeCameraModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Object checkPermissions(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::checkPermissions) == 1,
          "Expected checkPermissions(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::checkPermissions, jsInvoker_, instance_);
    }
    jsi::Object requestPermissions(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::requestPermissions) == 1,
          "Expected requestPermissions(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::requestPermissions, jsInvoker_, instance_);
    }
    jsi::Array getAvailableDevices(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getAvailableDevices) == 1,
          "Expected getAvailableDevices(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getAvailableDevices, jsInvoker_, instance_);
    }
    std::optional<jsi::Object> getCurrentDevice(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getCurrentDevice) == 1,
          "Expected getCurrentDevice(...) to have 1 parameters");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getCurrentDevice, jsInvoker_, instance_);
    }
    bool selectDevice(jsi::Runtime &rt, jsi::String deviceId) override {
      static_assert(
          bridging::getParameterCount(&T::selectDevice) == 2,
          "Expected selectDevice(...) to have 2 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::selectDevice, jsInvoker_, instance_, std::move(deviceId));
    }
    bool switchDevice(jsi::Runtime &rt, jsi::String position) override {
      static_assert(
          bridging::getParameterCount(&T::switchDevice) == 2,
          "Expected switchDevice(...) to have 2 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::switchDevice, jsInvoker_, instance_, std::move(position));
    }
    bool startCamera(jsi::Runtime &rt, jsi::String deviceId) override {
      static_assert(
          bridging::getParameterCount(&T::startCamera) == 2,
          "Expected startCamera(...) to have 2 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::startCamera, jsInvoker_, instance_, std::move(deviceId));
    }
    bool stopCamera(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::stopCamera) == 1,
          "Expected stopCamera(...) to have 1 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::stopCamera, jsInvoker_, instance_);
    }
    bool isActive(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::isActive) == 1,
          "Expected isActive(...) to have 1 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::isActive, jsInvoker_, instance_);
    }
    jsi::Object capturePhoto(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::capturePhoto) == 2,
          "Expected capturePhoto(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::capturePhoto, jsInvoker_, instance_, std::move(options));
    }
    bool startRecording(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::startRecording) == 2,
          "Expected startRecording(...) to have 2 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::startRecording, jsInvoker_, instance_, std::move(options));
    }
    jsi::Object stopRecording(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::stopRecording) == 1,
          "Expected stopRecording(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::stopRecording, jsInvoker_, instance_);
    }
    bool isRecording(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::isRecording) == 1,
          "Expected isRecording(...) to have 1 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::isRecording, jsInvoker_, instance_);
    }
    jsi::Object getRecordingProgress(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getRecordingProgress) == 1,
          "Expected getRecordingProgress(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getRecordingProgress, jsInvoker_, instance_);
    }
    bool hasFlash(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::hasFlash) == 1,
          "Expected hasFlash(...) to have 1 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::hasFlash, jsInvoker_, instance_);
    }
    bool setFlashMode(jsi::Runtime &rt, jsi::String mode) override {
      static_assert(
          bridging::getParameterCount(&T::setFlashMode) == 2,
          "Expected setFlashMode(...) to have 2 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::setFlashMode, jsInvoker_, instance_, std::move(mode));
    }
    bool setTorchMode(jsi::Runtime &rt, bool enabled) override {
      static_assert(
          bridging::getParameterCount(&T::setTorchMode) == 2,
          "Expected setTorchMode(...) to have 2 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::setTorchMode, jsInvoker_, instance_, std::move(enabled));
    }
    double getMinZoom(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getMinZoom) == 1,
          "Expected getMinZoom(...) to have 1 parameters");

      return bridging::callFromJs<double>(
          rt, &T::getMinZoom, jsInvoker_, instance_);
    }
    double getMaxZoom(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getMaxZoom) == 1,
          "Expected getMaxZoom(...) to have 1 parameters");

      return bridging::callFromJs<double>(
          rt, &T::getMaxZoom, jsInvoker_, instance_);
    }
    bool setZoom(jsi::Runtime &rt, double level) override {
      static_assert(
          bridging::getParameterCount(&T::setZoom) == 2,
          "Expected setZoom(...) to have 2 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::setZoom, jsInvoker_, instance_, std::move(level));
    }
    jsi::String getWhiteBalanceMode(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getWhiteBalanceMode) == 1,
          "Expected getWhiteBalanceMode(...) to have 1 parameters");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getWhiteBalanceMode, jsInvoker_, instance_);
    }
    bool setWhiteBalanceMode(jsi::Runtime &rt, jsi::String mode) override {
      static_assert(
          bridging::getParameterCount(&T::setWhiteBalanceMode) == 2,
          "Expected setWhiteBalanceMode(...) to have 2 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::setWhiteBalanceMode, jsInvoker_, instance_, std::move(mode));
    }
    double getWhiteBalanceTemperature(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getWhiteBalanceTemperature) == 1,
          "Expected getWhiteBalanceTemperature(...) to have 1 parameters");

      return bridging::callFromJs<double>(
          rt, &T::getWhiteBalanceTemperature, jsInvoker_, instance_);
    }
    bool setWhiteBalanceTemperature(jsi::Runtime &rt, double kelvin) override {
      static_assert(
          bridging::getParameterCount(&T::setWhiteBalanceTemperature) == 2,
          "Expected setWhiteBalanceTemperature(...) to have 2 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::setWhiteBalanceTemperature, jsInvoker_, instance_, std::move(kelvin));
    }
    double getWhiteBalanceTint(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getWhiteBalanceTint) == 1,
          "Expected getWhiteBalanceTint(...) to have 1 parameters");

      return bridging::callFromJs<double>(
          rt, &T::getWhiteBalanceTint, jsInvoker_, instance_);
    }
    bool setWhiteBalanceTint(jsi::Runtime &rt, double tint) override {
      static_assert(
          bridging::getParameterCount(&T::setWhiteBalanceTint) == 2,
          "Expected setWhiteBalanceTint(...) to have 2 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::setWhiteBalanceTint, jsInvoker_, instance_, std::move(tint));
    }
    jsi::Object getWhiteBalanceGains(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getWhiteBalanceGains) == 1,
          "Expected getWhiteBalanceGains(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getWhiteBalanceGains, jsInvoker_, instance_);
    }
    bool setWhiteBalanceGains(jsi::Runtime &rt, double red, double green, double blue) override {
      static_assert(
          bridging::getParameterCount(&T::setWhiteBalanceGains) == 4,
          "Expected setWhiteBalanceGains(...) to have 4 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::setWhiteBalanceGains, jsInvoker_, instance_, std::move(red), std::move(green), std::move(blue));
    }
    jsi::Array getSupportedWhiteBalanceModes(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getSupportedWhiteBalanceModes) == 1,
          "Expected getSupportedWhiteBalanceModes(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getSupportedWhiteBalanceModes, jsInvoker_, instance_);
    }
    jsi::Object getWhiteBalanceTemperatureRange(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getWhiteBalanceTemperatureRange) == 1,
          "Expected getWhiteBalanceTemperatureRange(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getWhiteBalanceTemperatureRange, jsInvoker_, instance_);
    }
    jsi::Object getPreviewSize(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getPreviewSize) == 1,
          "Expected getPreviewSize(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getPreviewSize, jsInvoker_, instance_);
    }
    jsi::Array getSupportedFormats(jsi::Runtime &rt, jsi::String deviceId) override {
      static_assert(
          bridging::getParameterCount(&T::getSupportedFormats) == 2,
          "Expected getSupportedFormats(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getSupportedFormats, jsInvoker_, instance_, std::move(deviceId));
    }

  private:
    friend class NativeCameraModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};

} // namespace facebook::react
